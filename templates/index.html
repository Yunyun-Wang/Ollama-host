<!DOCTYPE html>
<html>
<head>
    <title>Ollama Chat Interface</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=yes">
    <!-- Prevent caching -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Add cache busting parameter from Flask -->
    <meta name="cache-bust" content="{{ cache_bust }}">
    
    <!-- External libraries -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <!-- Common languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/html.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/css.min.js"></script>
    <!-- Add KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntxDrLqv4NxpM0LJ5GU3aIlOIZuX0QyYK" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    
    <style>
        /* Fix the body and app container to handle scrolling properly */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8fafc;
            color: #334155;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }

        .app-container {
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        /* Make the main container take full height and handle scrolling */
        .main-container {
            display: flex;
            flex: 1;
            height: calc(100vh - 140px); /* Set fixed height */
            min-height: calc(100vh - 140px);
            position: relative;
            margin-bottom: 0; /* Remove bottom margin */
        }
        
        /* Fix the sidebar to follow scroll */
        .sidebar {
            width: 250px;
            min-width: 250px;
            background-color: white;
            border-right: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            margin-right: 20px;
            height: calc(100vh - 140px);
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            position: sticky;
            top: 20px;
        }
        
        .sidebar-header {
            padding: 16px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .new-chat-btn {
            width: 100%;
            padding: 10px;
            background-color: #64748b;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        
        .new-chat-btn:hover {
            background-color: #475569;
        }
        
        /* Adjust the conversation list to take available space */
        .conversation-list {
            flex: 1;
            overflow-y: auto;
            padding-bottom: 70px; /* Make room for footer */
        }
        
        .conversation-item {
            padding: 12px 16px;
            border-bottom: 1px solid #f1f5f9;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .conversation-item:hover {
            background-color: #f8fafc;
        }
        
        .conversation-item.active {
            background-color: #e2e8f0;
            font-weight: 500;
        }
        
        .conversation-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }
        
        .delete-btn {
            visibility: hidden;
            background-color: transparent;
            color: #ef4444;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .conversation-item:hover .delete-btn {
            visibility: visible;
        }
        
        .delete-btn:hover {
            background-color: rgba(239, 68, 68, 0.1);
        }
        
        /* Keep the footer at the bottom of the sidebar */
        .sidebar-footer {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 16px;
            border-top: 1px solid #e2e8f0;
            background-color: white;
            border-radius: 0 0 12px 12px;
            z-index: 10;
        }
        
        .clear-all-btn {
            width: 100%;
            padding: 8px 10px;
            background-color: #f1f5f9;
            color: #ef4444;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .clear-all-btn:hover {
            background-color: #fee2e2;
            border-color: #fecaca;
        }
        
        .clear-all-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Update the chat container to include the input */
        #chat-container {
            flex: 1;
            min-height: 0;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            background-color: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            height: calc(100vh - 140px);
            max-height: calc(100vh - 140px);
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        /* Create a messages container inside the chat container */
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
            padding-bottom: 80px; /* Make room for input */
        }
        
        /* Update the input container to be inside the chat container */
        #input-container {
            display: flex;
            gap: 12px;
            padding: 16px;
            background-color: white;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 20;
            border-top: 1px solid #e2e8f0;
            flex-wrap: wrap; /* Allow wrapping if needed */
        }
        
        /* Remove the padding-bottom from chat wrapper since input is now inside chat container */
        .chat-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            width: calc(100% - 270px);
            position: relative;
            padding-bottom: 0;
            height: calc(100vh - 140px); /* Match the sidebar height */
        }

        .message {
            margin-bottom: 20px;
            padding: 16px;
            border-radius: 12px;
            line-height: 1.6;
            max-width: 85%;
        }

        .user-message {
            background-color: #64748b;
            color: white;
            margin-left: auto;
            box-shadow: 0 2px 4px rgba(100, 116, 139, 0.1);
        }

        .assistant-message {
            background-color: #f1f5f9;
            margin-right: auto;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        /* Make the input container sticky */
        #input-container {
            display: flex;
            gap: 12px;
            padding: 16px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 20; /* Ensure it stays on top */
        }

        #user-input {
            flex-grow: 1;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 15px;
            transition: border-color 0.2s;
        }

        #user-input:focus {
            outline: none;
            border-color: #64748b;
        }

        button {
            padding: 12px 24px;
            background-color: #64748b;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #475569;
        }

        #model-selector {
            padding: 10px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            min-width: 170px;
            font-size: 14px;
            color: #334155;
            background-color: white;
            transition: border-color 0.2s;
        }

        #model-selector:focus {
            outline: none;
            border-color: #64748b;
        }

        .controls label {
            font-size: 14px;
            font-weight: 500;
            color: #1e293b;
        }

        /* Markdown content styles */
        .message pre {
            background-color: #1e293b;
            color: #e2e8f0;
            padding: 16px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 12px 0;
        }
        
        .message pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            color: inherit;
        }
        
        .message code {
            background-color: rgba(226, 232, 240, 0.3);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-family: 'Fira Code', monospace;
            font-size: 0.9em;
        }

        .message p {
            margin: 0.8em 0;
        }

        .message ul, .message ol {
            margin: 0.8em 0;
            padding-left: 1.5em;
        }

        /* Thinking style */
        .thinking {
            font-style: italic !important;
            color: #64748b !important;
            display: block;
            margin: 0.8em 0;
            padding: 12px 16px;
            background-color: #f8fafc;
            border-left: 3px solid #64748b;
            border-radius: 4px;
        }

        /* Scrollbar styling */
        #chat-container::-webkit-scrollbar {
            width: 8px;
        }

        #chat-container::-webkit-scrollbar-track {
            background: #f1f5f9;
        }

        #chat-container::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        #chat-container::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Update CSS for the stop button to match the send button */
        .stop-btn {
            padding: 12px 26px;
            background-color: #ef4444;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
        }

        .stop-btn:hover {
            background-color: #dc2626;
        }

        /* Add a container for the stop button */
        #stop-button-container {
            position: sticky;
            bottom: 80px;
            width: 100%;
            display: flex;
            justify-content: center;
            padding: 10px 0;
            z-index: 25;
            display: none; /* Initially hidden */
        }

        /* Update the responsive design for mobile devices */
        @media (max-width: 768px) {
            .app-container {
                padding: 8px;
                max-width: 100%;
                width: 100%;
                box-sizing: border-box;
            }
            
            .main-container {
                flex-direction: column;
                height: auto;
                min-height: auto;
                width: 100%;
                max-width: 100%;
                overflow-x: hidden;
            }
            
            .sidebar {
                width: 100%;
                min-width: 100%;
                margin-right: 0;
                margin-bottom: 16px;
                height: auto;
                max-height: 300px; /* Limit height on mobile */
                position: relative;
                top: 0;
            }
            
            .chat-wrapper {
                width: 100%;
                height: calc(100vh - 460px); /* Adjust for the sidebar */
                max-width: 100%;
                overflow-x: hidden;
            }
            
            #chat-container {
                height: calc(100vh - 460px);
                max-height: calc(100vh - 460px);
                width: 100%;
                max-width: 100%;
                overflow-x: hidden;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
                width: 100%;
                max-width: 100%;
                padding: 8px;
            }
            
            #model-selector {
                width: 100%;
            }
            
            #input-container {
                padding: 8px;
                width: 100%;
                box-sizing: border-box;
            }
            
            #user-input {
                font-size: 16px; /* Prevent zoom on mobile */
                width: 100%;
                box-sizing: border-box;
            }
            
            button {
                padding: 10px 16px;
            }
            
            .message {
                max-width: 95%;
                word-wrap: break-word;
                overflow-wrap: break-word;
            }
            
            /* Ensure code blocks don't overflow */
            .message pre {
                max-width: 100%;
                overflow-x: auto;
            }
            
            /* Ensure images don't overflow */
            .message img {
                max-width: 100%;
                height: auto;
            }
            
            /* Make buttons wider on mobile */
            #input-container button {
                padding: 12px 30px;
                width: 100%;
                margin-top: 8px;
            }
            
            /* Adjust input container for stacked layout */
            #input-container {
                flex-direction: column;
                padding: 12px;
            }
            
            /* Make the input take full width */
            #user-input {
                width: 100%;
                box-sizing: border-box;
                padding: 14px;
                font-size: 16px;
            }
            
            /* Style the stop button to be more prominent */
            .stop-btn {
                width: 100%;
                padding: 12px 30px;
                margin-top: 8px;
            }
            
            /* Adjust chat container height when sidebar is hidden */
            .sidebar:not(.show) + .chat-wrapper #chat-container,
            .sidebar:not(.show) ~ .chat-wrapper {
                height: calc(100vh - 160px);
                max-height: calc(100vh - 160px);
            }
            
            /* Add JavaScript to update heights dynamically */
            .chat-wrapper-expanded {
                height: calc(100vh - 160px) !important;
            }
            
            #chat-container-expanded {
                height: calc(100vh - 160px) !important;
                max-height: calc(100vh - 160px) !important;
            }
        }

        /* Add a toggle button for the sidebar on mobile */
        .sidebar-toggle {
            display: none;
            padding: 8px 12px;
            background-color: #64748b;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            .sidebar-toggle {
                display: block;
            }
            
            .sidebar {
                display: none; /* Hide by default on mobile */
            }
            
            .sidebar.show {
                display: flex; /* Show when toggled */
            }
        }

        .user-info {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .logout-btn {
            padding: 6px 12px;
            background-color: #f1f5f9;
            color: #64748b;
            border-radius: 6px;
            text-decoration: none;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .logout-btn:hover {
            background-color: #e2e8f0;
        }
        
        @media (max-width: 768px) {
            .user-info {
                position: absolute;
                top: 10px;
                right: 10px;
                flex-direction: row;
                align-items: center;
                gap: 8px;
                margin-bottom: 0;
                background-color: rgba(255, 255, 255, 0.9);
                padding: 6px 10px;
                border-radius: 20px;
                font-size: 12px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                z-index: 100;
            }
            
            .user-info span {
                font-size: 12px;
            }
            
            .logout-btn {
                padding: 4px 8px;
                font-size: 12px;
                margin: 0;
            }
            
            .controls {
                padding-top: 40px;
                position: relative;
            }
            
            #model-selector {
                width: 100%;
                margin-top: 10px;
            }
        }

        /* Add styles for LaTeX rendering */
        .katex-display {
            margin: 1em 0;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 0.5em 0;
        }

        .katex {
            font-size: 1.1em;
        }

        .message .katex-display {
            background-color: #f8fafc;
            border-radius: 6px;
            padding: 10px;
        }

        .thinking .katex-display {
            background-color: #f1f5f9;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="controls">
            <label for="model-selector">Model:</label>
            <select id="model-selector"></select>
            <div class="user-info">
                <span>Logged in as: {{ username }}</span>
                <a href="{{ url_for('logout') }}" class="logout-btn">Logout</a>
            </div>
        </div>
        
        <button class="sidebar-toggle" id="sidebar-toggle">Show Conversations</button>
        
        <div class="main-container">
            <!-- Sidebar for conversations -->
            <div class="sidebar">
                <div class="sidebar-header">
                    <button class="new-chat-btn" onclick="startNewChat()">New Chat</button>
                </div>
                <div class="conversation-list" id="conversation-list">
                    <!-- Conversation items will be added here -->
                </div>
                <div class="sidebar-footer">
                    <button class="clear-all-btn" onclick="clearAllConversations()">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            <line x1="10" y1="11" x2="10" y2="17"></line>
                            <line x1="14" y1="11" x2="14" y2="17"></line>
                        </svg>
                        Clear All Chats
                    </button>
                </div>
            </div>
            
            <!-- Chat area -->
            <div class="chat-wrapper">
                <div id="chat-container">
                    <div class="messages-container" id="messages-container">
                        <!-- Messages will be added here -->
                    </div>
                    <div id="input-container">
                        <input type="text" id="user-input" placeholder="Type your message here..." autocomplete="off">
                        <button onclick="sendMessage()">Send</button>
                        <!-- Add the stop button here, initially hidden -->
                        <button id="stop-button" class="stop-btn" style="display: none;" onclick="stopGeneration()">Stop</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configure marked.js
        marked.setOptions({
            breaks: true,
            gfm: true,
            headerIds: false,
            mangle: false,
            sanitize: false,
            silent: true,
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(code, { language: lang }).value;
                    } catch (e) {
                        console.error(e);
                    }
                }
                return hljs.highlightAuto(code).value;
            }
        });

        // Global variables
        let messageHistory = [];
        let currentModel = null;
        let conversations = [];
        let currentConversationId = null;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            loadModels();
            initConversations();
            
            // Add event listeners
            document.getElementById('user-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            document.getElementById('model-selector').addEventListener('change', function(e) {
                currentModel = e.target.value;
                
                // Only clear if this is a new conversation
                if (messageHistory.length === 0) {
                    document.getElementById('chat-container').innerHTML = '';
                }
            });
            
            // Add the stop button
            addStopButton();

            // Add sidebar toggle functionality for mobile
            const sidebarToggle = document.getElementById('sidebar-toggle');
            const sidebar = document.querySelector('.sidebar');
            const chatWrapper = document.querySelector('.chat-wrapper');
            const chatContainer = document.getElementById('chat-container');
            
            if (sidebarToggle && sidebar) {
                sidebarToggle.addEventListener('click', function() {
                    sidebar.classList.toggle('show');
                    sidebarToggle.textContent = sidebar.classList.contains('show') ? 
                        'Hide Conversations' : 'Show Conversations';
                    
                    // Toggle expanded class on chat wrapper and container
                    if (!sidebar.classList.contains('show')) {
                        // Sidebar is hidden, expand chat area
                        chatWrapper.classList.add('chat-wrapper-expanded');
                        chatContainer.classList.add('chat-container-expanded');
                    } else {
                        // Sidebar is shown, revert chat area
                        chatWrapper.classList.remove('chat-wrapper-expanded');
                        chatContainer.classList.remove('chat-container-expanded');
                    }
                    
                    // Force a scroll update
                    setTimeout(() => {
                        const messagesContainer = document.getElementById('messages-container');
                        if (messagesContainer) {
                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        }
                    }, 100);
                });
                
                // Initialize on page load - if sidebar is hidden by default on mobile
                if (window.innerWidth <= 768 && !sidebar.classList.contains('show')) {
                    chatWrapper.classList.add('chat-wrapper-expanded');
                    chatContainer.classList.add('chat-container-expanded');
                }
            }
            
            // Add viewport meta tag for proper mobile scaling
            const meta = document.createElement('meta');
            meta.name = 'viewport';
            meta.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
            document.getElementsByTagName('head')[0].appendChild(meta);
        });

        // Save conversation when page is unloaded
        window.addEventListener('beforeunload', saveCurrentConversation);

        // Load available models
        async function loadModels() {
            try {
                const response = await fetch('/models');
                const data = await response.json();
                
                if (data && data.models) {
                    const modelSelector = document.getElementById('model-selector');
                    modelSelector.innerHTML = '';
                    
                    // Sort models alphabetically
                    const sortedModels = data.models.sort((a, b) => a.name.localeCompare(b.name));
                    
                    sortedModels.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.name;
                        option.textContent = model.name;
                        modelSelector.appendChild(option);
                    });
                    
                    // Set the default model if available
                    if (currentModel && sortedModels.some(m => m.name === currentModel)) {
                        modelSelector.value = currentModel;
                    } else if (sortedModels.length > 0) {
                        // Set the first model as default
                        currentModel = sortedModels[0].name;
                        modelSelector.value = currentModel;
                    }
                }
            } catch (error) {
                console.error('Error loading models:', error);
            }
        }

        // Initialize conversations from server
        async function initConversations() {
            try {
                // First try to load from server
                const response = await fetch('/conversations');
                const data = await response.json();
                
                if (data.conversations) {
                    conversations = data.conversations;
                    renderConversationList();
                    
                    // Load the most recent conversation if available
                    if (conversations.length > 0) {
                        loadConversation(conversations[0].id);
                    } else {
                        startNewChat();
                    }
                } else {
                    startNewChat();
                }
            } catch (error) {
                console.error('Error loading conversations from server:', error);
                // Fallback to localStorage if server fails
                const savedConversations = localStorage.getItem('ollama-conversations');
                if (savedConversations) {
                    conversations = JSON.parse(savedConversations);
                    renderConversationList();
                    
                    if (conversations.length > 0) {
                        loadConversation(conversations[0].id);
                    } else {
                        startNewChat();
                    }
                } else {
                    startNewChat();
                }
            }
        }

        // Save conversations to server and localStorage
        async function saveConversations() {
            // Save to localStorage as backup
            localStorage.setItem('ollama-conversations', JSON.stringify(conversations));
            
            // We don't need to save all conversations to server at once
            // Individual conversations are saved when they're updated
        }

        // Start a new chat
        async function startNewChat() {
            // Get the current model from the selector
            const modelSelector = document.getElementById('model-selector');
            currentModel = modelSelector ? modelSelector.value : 'deepseek-r1:7b';
            
            // Only create a new chat if we don't already have one in progress
            if (!currentConversationId || messageHistory.length > 0) {
                // Generate a new conversation ID
                const conversationId = generateUUID();
                
                // IMPORTANT: Reset the message history
                messageHistory = [];
                
                // Set the current conversation ID
                currentConversationId = conversationId;
                
                // Add to conversations array
                conversations.push({
                    id: conversationId,
                    title: 'New Chat',
                    messages: [],
                    model: currentModel,
                    updated_at: Date.now()
                });
                
                // Clear the messages container
                const messagesContainer = document.getElementById('messages-container');
                messagesContainer.innerHTML = '';
                
                // Update the conversation list
                renderConversationList();
                
                // Mark this conversation as active
                document.querySelectorAll('.conversation-item').forEach(item => {
                    item.classList.remove('active');
                    if (item.dataset.id === conversationId) {
                        item.classList.add('active');
                    }
                });
            }
        }

        // Update saveCurrentConversation to be more robust
        async function saveCurrentConversation() {
            if (!currentConversationId) {
                console.error("Cannot save conversation: No current conversation ID");
                return;
            }
            
            console.log("Saving conversation:", currentConversationId);
            console.log("Message history length:", messageHistory.length);
            
            // Find the current conversation in the array
            const conversationIndex = conversations.findIndex(c => c.id === currentConversationId);
            
            let conversationToSave;
            
            if (conversationIndex !== -1) {
                // Preserve the existing title
                const existingTitle = conversations[conversationIndex].title;
                
                // Update the conversation with new messages but keep the title
                conversationToSave = {
                    id: currentConversationId,
                    title: existingTitle,
                    messages: [...messageHistory], // Create a copy to avoid reference issues
                    model: currentModel,
                    updated_at: Date.now()
                };
                
                // Update in local array
                conversations[conversationIndex] = conversationToSave;
            } else {
                // Create a new conversation object if not found
                conversationToSave = {
                    id: currentConversationId,
                    title: 'New Chat',
                    messages: [...messageHistory],
                    model: currentModel,
                    updated_at: Date.now()
                };
                
                // Add to local array
                conversations.unshift(conversationToSave);
            }
            
            // Save to server
            try {
                console.log("Sending conversation to server:", conversationToSave);
                const response = await fetch('/conversations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(conversationToSave)
                });
                
                const data = await response.json();
                console.log("Server response:", data);
                
                if (!data.success) {
                    console.error("Server reported error when saving conversation");
                }
            } catch (error) {
                console.error('Error saving conversation to server:', error);
            }
            
            // Save to localStorage
            saveConversations();
            
            // Update UI
            renderConversationList();
        }

        // Load a conversation
        async function loadConversation(conversationId) {
            try {
                const response = await fetch(`/conversations/${conversationId}`);
                const conversation = await response.json();
                
                // Set the current conversation ID
                currentConversationId = conversationId;
                
                // Set the current model
                currentModel = conversation.model || 'deepseek-r1:7b';
                const modelSelector = document.getElementById('model-selector');
                if (modelSelector && currentModel) {
                    // Try to set the model selector to match the conversation's model
                    if (Array.from(modelSelector.options).some(option => option.value === currentModel)) {
                        modelSelector.value = currentModel;
                    }
                }
                
                // IMPORTANT: Set the message history from the loaded conversation
                messageHistory = conversation.messages ? [...conversation.messages] : [];
                
                // Clear the messages container
                const messagesContainer = document.getElementById('messages-container');
                messagesContainer.innerHTML = '';
                
                // Add each message to the chat
                if (messageHistory && messageHistory.length > 0) {
                    messageHistory.forEach(message => {
                        addMessageToChat(message.role, message.content);
                    });
                }
                
                // Mark this conversation as active in the sidebar
                document.querySelectorAll('.conversation-item').forEach(item => {
                    item.classList.remove('active');
                    if (item.dataset.id === conversationId) {
                        item.classList.add('active');
                    }
                });
                
                // Scroll to the bottom of the messages
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                return true;
            } catch (error) {
                console.error('Error loading conversation:', error);
                return false;
            }
        }

        // Delete a conversation
        async function deleteConversation(id, event) {
            event.stopPropagation();
            
            try {
                // Delete from server
                const response = await fetch(`/conversations/${id}`, {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                if (!data.success) {
                    console.error('Error deleting conversation from server');
                }
            } catch (error) {
                console.error('Error deleting conversation from server:', error);
            }
            
            // Delete locally
            const index = conversations.findIndex(c => c.id === id);
            if (index !== -1) {
                conversations.splice(index, 1);
                saveConversations();
                
                // If we deleted the current conversation, load another one
                if (id === currentConversationId) {
                    if (conversations.length > 0) {
                        loadConversation(conversations[0].id);
                    } else {
                        startNewChat();
                    }
                } else {
                    renderConversationList();
                }
            }
        }

        // Render the conversation list
        function renderConversationList() {
            console.log("=== RENDER LIST DEBUG ===");
            const listElement = document.getElementById('conversation-list');
            console.log("Rendering conversation list with", conversations.length, "conversations");
            console.log("Current conversation ID:", currentConversationId);
            
            listElement.innerHTML = '';
            
            conversations.forEach(conversation => {
                console.log("Rendering conversation:", conversation.id, conversation.title);
                
                const item = document.createElement('div');
                item.className = `conversation-item${conversation.id === currentConversationId ? ' active' : ''}`;
                item.onclick = () => loadConversation(conversation.id);
                
                const title = document.createElement('div');
                title.className = 'conversation-title';
                title.textContent = conversation.title;
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.onclick = (e) => deleteConversation(conversation.id, e);
                
                item.appendChild(title);
                item.appendChild(deleteBtn);
                listElement.appendChild(item);
            });
            
            console.log("Final conversation list HTML:", listElement.innerHTML);
            console.log("=== END RENDER LIST DEBUG ===");
        }

        // Add a message to the chat
        function addMessageToChat(role, content) {
            const messagesContainer = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}-message`;
            
            if (role === 'assistant') {
                // First parse the markdown
                let parsedContent = marked.parse(content);
                
                // Then handle the thinking sections
                parsedContent = parsedContent.replace(/<think>([\s\S]*?)<\/think>/g, (match, thinking) => {
                    // Remove any <p> tags that marked might have added
                    thinking = thinking.replace(/<\/?p>/g, '');
                    return `<span class="thinking">${thinking}</span>`;
                });
                
                messageDiv.innerHTML = parsedContent;
                
                // Apply syntax highlighting
                messageDiv.querySelectorAll('pre code').forEach((block) => {
                    hljs.highlightElement(block);
                });
            } else {
                messageDiv.textContent = content;
            }
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Add a more visible stop button to the messages container
        function addStopButton() {
            // Remove any existing stop button first
            const existingButton = document.getElementById('stop-button-container');
            if (existingButton) {
                existingButton.remove();
            }
            
            const messagesContainer = document.getElementById('messages-container');
            
            // Create a container for the stop button
            const stopButtonContainer = document.createElement('div');
            stopButtonContainer.id = 'stop-button-container';
            stopButtonContainer.style.position = 'fixed';
            stopButtonContainer.style.bottom = '100px';
            stopButtonContainer.style.left = '50%';
            stopButtonContainer.style.transform = 'translateX(-50%)';
            stopButtonContainer.style.zIndex = '1000';
            stopButtonContainer.style.display = 'none';
            stopButtonContainer.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
            stopButtonContainer.style.padding = '10px';
            stopButtonContainer.style.borderRadius = '8px';
            stopButtonContainer.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.15)';
            
            // Create the stop button
            const stopButton = document.createElement('button');
            stopButton.id = 'stop-button';
            stopButton.className = 'stop-btn';
            stopButton.innerHTML = 'Stop';
            stopButton.style.padding = '10px 20px';
            stopButton.style.backgroundColor = '#ef4444';
            stopButton.style.color = 'white';
            stopButton.style.border = 'none';
            stopButton.style.borderRadius = '6px';
            stopButton.style.fontWeight = 'bold';
            stopButton.style.cursor = 'pointer';
            stopButton.onclick = stopGeneration;
            
            // Add the button to the container
            stopButtonContainer.appendChild(stopButton);
            
            // Add the container to the document body (not the messages container)
            document.body.appendChild(stopButtonContainer);
            
            console.log("Stop button added:", stopButton);
        }

        // Function to show the stop button and hide the send button
        function showStopButton() {
            const stopButton = document.getElementById('stop-button');
            const sendButton = document.querySelector('#input-container button:not(#stop-button)');
            
            if (stopButton) {
                stopButton.style.display = 'block';
                console.log("Stop button should be visible now");
            }
            
            if (sendButton) {
                sendButton.style.display = 'none';
                console.log("Send button should be hidden now");
            }
        }

        // Function to hide the stop button and show the send button
        function hideStopButton() {
            const stopButton = document.getElementById('stop-button');
            const sendButton = document.querySelector('#input-container button:not(#stop-button)');
            
            if (stopButton) {
                stopButton.style.display = 'none';
                console.log("Stop button hidden");
            }
            
            if (sendButton) {
                sendButton.style.display = 'block';
                console.log("Send button visible");
            }
            
            // Also clear the controller to be safe
            currentController = null;
        }

        // Global variable to track the current fetch controller
        let currentController = null;

        // Function to stop the generation
        function stopGeneration() {
            if (currentController) {
                console.log("Stopping generation...");
                currentController.abort();
                currentController = null;
                
                // Hide stop button and show send button
                hideStopButton();
            }
        }

        // Add a more robust error handling approach specifically for network connection losses
        async function sendMessage() {
            console.log("=== STARTING NEW MESSAGE SEND ===");
            console.log("Current conversation ID:", currentConversationId);
            console.log("Message history length:", messageHistory.length);
            
            // Get the input value
            const userInput = document.getElementById('user-input').value.trim();
            
            // Get the selected model
            const modelSelector = document.getElementById('model-selector');
            const selectedModel = modelSelector.value;
            console.log("Using model:", selectedModel);
            
            if (!userInput) return;

            // Add user message to chat
            addMessageToChat('user', userInput);
            document.getElementById('user-input').value = '';

            // Add message to history
            messageHistory.push({
                "role": "user",
                "content": userInput
            });
            console.log("Added user message to history. New length:", messageHistory.length);
            
            // Create a new conversation if needed
            if (!currentConversationId) {
                const conversationId = generateUUID();
                currentConversationId = conversationId;
                console.log("Created new conversation with ID:", conversationId);
                
                // Add to conversations array
                conversations.push({
                    id: conversationId,
                    title: 'New Chat',
                    messages: [...messageHistory],
                    model: selectedModel,
                    updated_at: Date.now()
                });
                
                // Update the UI
                renderConversationList();
            } else {
                // Update the existing conversation with the new message
                const conversationIndex = conversations.findIndex(c => c.id === currentConversationId);
                if (conversationIndex !== -1) {
                    conversations[conversationIndex].messages = [...messageHistory];
                    conversations[conversationIndex].updated_at = Date.now();
                    console.log("Updated existing conversation:", currentConversationId);
                }
            }
            
            // Save the conversation with the user's message
            await saveCurrentConversation();
            console.log("Saved conversation with user message");
            
            // Add a placeholder for the assistant's response
            const messagesContainer = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant-message';
            messageDiv.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div>';
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Show the stop button
            showStopButton();
            
            // Create a new AbortController for this request
            currentController = new AbortController();
            const signal = currentController.signal;
            
            let fullResponse = '';
            let responseBuffer = '';
            let totalBytesReceived = 0;
            let lastActivityTime = Date.now();
            
            // Set up a heartbeat to detect connection losses
            const heartbeatInterval = setInterval(() => {
                const inactiveTime = Date.now() - lastActivityTime;
                console.log(`Stream inactive for ${inactiveTime}ms`);
                
                // If no activity for more than 15 seconds, consider the connection lost
                if (inactiveTime > 15000) {
                    console.error("Connection appears to be lost - no activity for 15 seconds");
                    clearInterval(heartbeatInterval);
                    
                    // Save what we have so far
                    if (fullResponse) {
                        console.log("Connection lost. Saving partial response of length:", fullResponse.length);
                        
                        // Update the display with what we have so far
                        updateMessageDisplay(messageDiv, fullResponse + "\n\n*Connection lost. Response may be incomplete.*");
                        
                        // Add the partial response to message history
                        messageHistory.push({
                            "role": "assistant",
                            "content": fullResponse + "\n\n*Connection lost. Response may be incomplete.*"
                        });
                        
                        // Save the conversation with the partial response
                        saveCurrentConversation().then(() => {
                            console.log("Saved partial response after connection loss");
                        }).catch(e => {
                            console.error("Failed to save partial response:", e);
                        });
                        
                        // Hide the stop button
                        hideStopButton();
                        
                        // If the controller is still active, abort it
                        if (currentController) {
                            try {
                                currentController.abort();
                                currentController = null;
                            } catch (e) {
                                console.error("Error aborting controller:", e);
                            }
                        }
                    }
                }
            }, 5000); // Check every 5 seconds
            
            try {
                console.log("Sending request to server...");
                console.time("serverResponseTime");
                
                // Important: Send the FULL message history to maintain context
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        messages: messageHistory,  // Send the complete message history
                        model: selectedModel,
                        conversation_id: currentConversationId,
                        stream: true
                    }),
                    signal: signal
                });
                
                console.timeEnd("serverResponseTime");
                console.log("Initial response received from server:", response.status, response.statusText);
                
                if (!response.ok) {
                    throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                }
                
                // Handle streaming response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    try {
                        // Update activity timestamp
                        lastActivityTime = Date.now();
                        
                        const { done, value } = await reader.read();
                        
                        if (done) {
                            console.log("Stream complete (done=true)");
                            clearInterval(heartbeatInterval);
                            
                            // Make sure we process any remaining data in the buffer
                            if (responseBuffer) {
                                try {
                                    const lines = responseBuffer.split('\n\n');
                                    for (const line of lines) {
                                        if (line.startsWith('data: ')) {
                                            const data = JSON.parse(line.substring(6));
                                            if (data.full_response) {
                                                fullResponse = data.full_response;
                                            }
                                        }
                                    }
                                } catch (e) {
                                    console.error('Error processing buffer at end:', e);
                                }
                            }
                            
                            // Final update with the complete response
                            updateMessageDisplay(messageDiv, fullResponse);
                            
                            // Add the complete response to message history
                            messageHistory.push({
                                "role": "assistant",
                                "content": fullResponse
                            });
                            
                            // Save the conversation with the assistant's response
                            await saveCurrentConversation();
                            
                            // Generate a title if this is a new conversation with default title
                            const currentConversationIndex = conversations.findIndex(c => c.id === currentConversationId);
                            if (currentConversationIndex !== -1) {
                                const currentConversation = conversations[currentConversationIndex];
                                if (currentConversation.title === 'New Chat') {
                                    // Wait a moment to ensure everything is saved
                                    setTimeout(async () => {
                                        await summarizeAndRenameConversation();
                                        // Force a UI update
                                        renderConversationList();
                                    }, 500);
                                }
                            }
                            
                            // Make sure to hide the stop button
                            hideStopButton();
                            
                            break;
                        }
                        
                        if (!value || value.length === 0) {
                            console.warn("Received empty chunk, continuing...");
                            continue;
                        }
                        
                        totalBytesReceived += value.length;
                        
                        const chunk = decoder.decode(value, { stream: true });
                        responseBuffer += chunk;
                        
                        // Process complete events in the buffer
                        const lines = responseBuffer.split('\n\n');
                        responseBuffer = lines.pop() || ''; // Keep the last incomplete line in the buffer
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.substring(6));
                                    
                                    // Handle keepalive messages
                                    if (data.keepalive) {
                                        console.log("Received keepalive from server");
                                        continue;
                                    }
                                    
                                    if (data.content) {
                                        fullResponse += data.content;
                                    }
                                    
                                    if (data.full_response) {
                                        fullResponse = data.full_response;
                                    }
                                    
                                    if (data.error) {
                                        console.error("Server reported error:", data.error);
                                        throw new Error(`Server error: ${data.error}`);
                                    }
                                    
                                    // Update the display with what we have so far
                                    updateMessageDisplay(messageDiv, fullResponse);
                                    
                                    if (data.done) {
                                        console.log("Received done signal from server");
                                        clearInterval(heartbeatInterval);
                                        
                                        // Final update with complete response
                                        updateMessageDisplay(messageDiv, fullResponse);
                                        
                                        // Add the complete response to message history
                                        messageHistory.push({
                                            "role": "assistant",
                                            "content": fullResponse
                                        });
                                        
                                        // Save the conversation with the assistant's response
                                        await saveCurrentConversation();
                                        
                                        // Generate a title if this is a new conversation with default title
                                        const currentConversationIndex = conversations.findIndex(c => c.id === currentConversationId);
                                        if (currentConversationIndex !== -1) {
                                            const currentConversation = conversations[currentConversationIndex];
                                            if (currentConversation.title === 'New Chat') {
                                                // Wait a moment to ensure everything is saved
                                                setTimeout(async () => {
                                                    await summarizeAndRenameConversation();
                                                    // Force a UI update
                                                    renderConversationList();
                                                }, 500);
                                            }
                                        }
                                        
                                        // Make sure to hide the stop button
                                        hideStopButton();
                                        
                                        // Clear the controller
                                        currentController = null;
                                        
                                        // We're done, but we'll let the reader finish naturally
                                    }
                                } catch (e) {
                                    console.error('Error parsing SSE data:', e, line);
                                }
                            }
                        }
                    } catch (readError) {
                        console.error('=== STREAM READ ERROR ===');
                        console.error('Error type:', readError.constructor.name);
                        console.error('Error name:', readError.name);
                        console.error('Error message:', readError.message);
                        
                        // Clear the heartbeat interval
                        clearInterval(heartbeatInterval);
                        
                        // If we have a partial response, save it
                        if (fullResponse) {
                            console.log("Read error occurred. Saving partial response of length:", fullResponse.length);
                            
                            // Update the display with what we have so far
                            updateMessageDisplay(messageDiv, fullResponse + "\n\n*Connection error. Response may be incomplete.*");
                            
                            // Add the partial response to message history
                            messageHistory.push({
                                "role": "assistant",
                                "content": fullResponse + "\n\n*Connection error. Response may be incomplete.*"
                            });
                            
                            // Save the conversation with the partial response
                            await saveCurrentConversation();
                        }
                        
                        // Hide the stop button
                        hideStopButton();
                        
                        // Break out of the loop
                        break;
                    }
                }
            } catch (error) {
                console.error('=== ERROR IN CHAT ===');
                console.error('Error type:', error.constructor.name);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                
                // Clear the heartbeat interval
                clearInterval(heartbeatInterval);
                
                // Make sure to hide the stop button even if there's an error
                hideStopButton();
                
                // Show error message
                if (error.name === 'AbortError') {
                    // This is a normal abort, no need to show an error
                    console.log('Request was aborted by user');
                } else {
                    // Add an error message to the chat
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'message system-message';
                    errorDiv.textContent = `Error: ${error.message}`;
                    messagesContainer.appendChild(errorDiv);
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    
                    // If we have a partial response, try to save it
                    if (fullResponse) {
                        console.log("Attempting to save partial response after error");
                        try {
                            // Update the display with what we have so far
                            updateMessageDisplay(messageDiv, fullResponse + "\n\n*Error occurred. Response may be incomplete.*");
                            
                            // Add the partial response to message history
                            messageHistory.push({
                                "role": "assistant",
                                "content": fullResponse + "\n\n*Error occurred. Response may be incomplete.*"
                            });
                            
                            // Save the conversation with the partial response
                            await saveCurrentConversation();
                        } catch (saveError) {
                            console.error("Failed to save partial response:", saveError);
                        }
                    }
                }
            }
        }

        // Add LaTeX rendering support to the updateMessageDisplay function
        function updateMessageDisplay(messageDiv, content) {
            // Process the content for display
            let displayContent = content;
            
            // First extract all thinking sections
            const thinkingMatches = [];
            let processedContent = displayContent.replace(/<think>([\s\S]*?)<\/think>/g, (match, thinking) => {
                // Store the thinking content
                thinkingMatches.push(thinking);
                // Replace with a unique token that won't be affected by markdown parsing
                return `THINKING_TOKEN_${thinkingMatches.length - 1}_PLACEHOLDER`;
            });
            
            // Check for incomplete thinking section
            let incompleteThinking = null;
            if (content.includes('<think>') && !content.endsWith('</think>')) {
                // Find the last opening tag that doesn't have a closing tag
                const lastOpenTagPos = content.lastIndexOf('<think>');
                const lastCloseTagPos = content.lastIndexOf('</think>');
                
                // Only consider it incomplete if the last open tag comes after the last close tag
                if (lastOpenTagPos > lastCloseTagPos) {
                    incompleteThinking = content.substring(lastOpenTagPos + 7); // +7 to skip '<think>'
                    
                    // Remove the incomplete thinking from the processed content to avoid duplication
                    processedContent = processedContent.substring(0, processedContent.lastIndexOf('<think>'));
                }
            }
            
            // Parse the content with markdown
            let parsedContent = marked.parse(processedContent);
            
            // Now replace all thinking tokens with styled thinking sections
            for (let i = 0; i < thinkingMatches.length; i++) {
                const token = `THINKING_TOKEN_${i}_PLACEHOLDER`;
                const thinking = thinkingMatches[i];
                
                // Parse the thinking content with markdown as well
                const parsedThinking = marked.parse(thinking);
                
                // Create the replacement HTML - wrap the parsed markdown in a thinking div
                const thinkingHTML = `<div class="thinking">${parsedThinking}</div>`;
                
                // Replace all occurrences of the token, regardless of surrounding HTML
                while (parsedContent.includes(token)) {
                    parsedContent = parsedContent.replace(token, thinkingHTML);
                }
                
                // Also try with HTML-encoded versions
                const encodedToken = token.replace(/_/g, '&#95;');
                while (parsedContent.includes(encodedToken)) {
                    parsedContent = parsedContent.replace(encodedToken, thinkingHTML);
                }
            }
            
            // Add incomplete thinking section if present
            if (incompleteThinking) {
                // Parse the incomplete thinking with markdown
                const parsedIncompleteThinking = marked.parse(incompleteThinking);
                
                // Add the incomplete thinking section
                parsedContent += `<div class="thinking thinking-incomplete">${parsedIncompleteThinking}</div>`;
            }
            
            // Update the message content
            messageDiv.innerHTML = parsedContent;
            
            // Apply syntax highlighting to any code blocks
            messageDiv.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Also apply syntax highlighting to code blocks inside thinking sections
            messageDiv.querySelectorAll('.thinking pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Render LaTeX expressions
            renderMathInElement(messageDiv, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                throwOnError: false,
                output: 'html'
            });
            
            // Also render LaTeX in thinking sections
            messageDiv.querySelectorAll('.thinking').forEach((thinkingElement) => {
                renderMathInElement(thinkingElement, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\(', right: '\\)', display: false},
                        {left: '\\[', right: '\\]', display: true}
                    ],
                    throwOnError: false,
                    output: 'html'
                });
            });
            
            // Scroll to bottom
            const messagesContainer = document.getElementById('messages-container');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Update the summarizeAndRenameConversation function to be more reliable
        async function summarizeAndRenameConversation() {
            console.log("=== TITLE GENERATION DEBUG ===");
            console.log("Current conversation ID:", currentConversationId);
            
            // Only proceed if we have a conversation with the default title
            const currentConversationIndex = conversations.findIndex(c => c.id === currentConversationId);
            
            if (currentConversationIndex === -1) {
                console.error("DEBUG: No current conversation found with ID:", currentConversationId);
                return;
            }
            
            const currentConversation = conversations[currentConversationIndex];
            console.log("Current conversation:", currentConversation);
            console.log("Current conversation title:", currentConversation.title);
            
            if (currentConversation.title !== 'New Chat') {
                console.log("DEBUG: Conversation already has a non-default title:", currentConversation.title);
                return;
            }
            
            if (messageHistory.length < 2) {
                console.log("DEBUG: Not enough messages for title generation. Message count:", messageHistory.length);
                return;
            }
            
            // Get the first user message
            const firstUserMessage = messageHistory.find(m => m.role === 'user');
            
            if (!firstUserMessage) {
                console.error("DEBUG: No user message found in history:", messageHistory);
                return;
            }
            
            console.log("First user message:", firstUserMessage.content);
            
            try {
                console.log("Generating title using model...");
                
                // Create a separate request that won't affect the main conversation
                const titleRequest = {
                    messages: [
                        {
                            role: "system",
                            content: "You are a helpful assistant that generates short, concise titles (3-5 words) for conversations. Your response must be ONLY the title text - no quotes, no explanation, no thinking process, no markdown, just plain text. Keep it under 50 characters."
                        },
                        {
                            role: "user",
                            content: `Create a short, descriptive title (3-5 words) for a conversation that starts with this message: "${firstUserMessage.content}"`
                        }
                    ],
                    model: currentModel,
                    stream: false,
                    conversation_id: null // Explicitly set to null to avoid affecting any conversation
                };
                
                // Send the request to generate a title
                const titleResponse = await fetch('/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(titleRequest)
                });
                
                const titleData = await titleResponse.json();
                console.log("Title generation response:", titleData);
                
                let title;
                
                if (titleData && titleData.full_response) {
                    // Clean up the title (remove quotes, newlines, etc.)
                    title = titleData.full_response.trim();
                    
                    // Remove any <think> tags and their contents
                    title = title.replace(/<think>[\s\S]*?<\/think>/g, '');
                    
                    // Remove any other HTML/markdown tags
                    title = title.replace(/<[^>]*>/g, '');
                    
                    // Remove quotes, backticks, and other special characters
                    title = title.replace(/["'`*_#]/g, '');
                    
                    // Replace newlines with spaces
                    title = title.replace(/\n/g, ' ');
                    
                    // Collapse multiple spaces
                    title = title.replace(/\s+/g, ' ');
                    
                    // Limit length if needed
                    if (title.length > 50) {
                        title = title.substring(0, 50) + '...';
                    }
                    
                    // If title is empty after cleaning, use fallback
                    if (!title.trim()) {
                        throw new Error("Generated title was empty after cleaning");
                    }
                } else {
                    throw new Error("No title generated by model");
                }
                
                console.log("Generated title:", title);
                
                // Create a copy of the conversation to update
                const updatedConversation = {
                    ...currentConversation,
                    title: title
                };
                
                // Update the conversation title in the local array
                conversations[currentConversationIndex] = updatedConversation;
                console.log("Updated conversation in array:", conversations[currentConversationIndex]);
                
                // Save to server
                console.log("Sending updated conversation to server...");
                const response = await fetch('/conversations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updatedConversation)
                });
                
                const responseData = await response.json();
                console.log("Server response:", responseData);
                
                if (responseData.success) {
                    console.log("Server successfully saved the title");
                    
                    // Update the UI
                    console.log("Updating UI...");
                    renderConversationList();
                    
                    return title;
                } else {
                    console.error("Server reported error when saving conversation");
                    throw new Error("Server error when saving title");
                }
            } catch (error) {
                console.error('Error generating or saving title:', error);
                
                // Fallback to a simple title if there's an error
                const fallbackTitle = firstUserMessage.content.substring(0, 30) + 
                                     (firstUserMessage.content.length > 30 ? '...' : '');
                
                // Create a copy of the conversation to update
                const updatedConversation = {
                    ...currentConversation,
                    title: fallbackTitle
                };
                
                conversations[currentConversationIndex] = updatedConversation;
                
                // Save to server
                try {
                    const response = await fetch('/conversations', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(updatedConversation)
                    });
                    
                    if (response.ok) {
                        console.log("Saved fallback title to server");
                        renderConversationList();
                        return fallbackTitle;
                    }
                } catch (e) {
                    console.error("Error saving fallback title:", e);
                }
                
                renderConversationList();
                return fallbackTitle;
            }
        }

        // Add this function to your JavaScript
        async function clearAllConversations() {
            // Ask for confirmation
            if (confirm('Are you sure you want to delete all conversations? This cannot be undone.')) {
                try {
                    // Clear from server
                    const response = await fetch('/conversations/clear', {
                        method: 'POST'
                    });
                    
                    const data = await response.json();
                    if (!data.success) {
                        console.error('Error clearing conversations from server');
                    }
                } catch (error) {
                    console.error('Error clearing conversations from server:', error);
                }
                
                // Clear locally
                conversations = [];
                saveConversations();
                
                // Reset the current conversation state
                currentConversationId = null;
                messageHistory = [];
                
                // Clear the messages container
                const messagesContainer = document.getElementById('messages-container');
                if (messagesContainer) {
                    messagesContainer.innerHTML = '';
                }
                
                // Create a single new chat
                console.log("Creating a single new chat after clearing all");
                startNewChat();
                
                // Update the UI
                renderConversationList();
            }
        }

        // Helper function to generate UUIDs on the client side
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Add event listener to the stop button
        document.addEventListener('DOMContentLoaded', function() {
            // Add event listener to the stop button
            const stopButton = document.getElementById('stop-button-fixed');
            if (stopButton) {
                stopButton.addEventListener('click', stopGeneration);
            } else {
                console.error("Stop button not found in DOM");
            }
        });

        // Add an event listener to save the selected model when it changes
        document.addEventListener('DOMContentLoaded', function() {
            const modelSelector = document.getElementById('model-selector');
            if (modelSelector) {
                modelSelector.addEventListener('change', function() {
                    currentModel = modelSelector.value;
                    console.log('Model changed to:', currentModel);
                    
                    // If we have a current conversation, update its model
                    if (currentConversationId) {
                        const currentConversationIndex = conversations.findIndex(c => c.id === currentConversationId);
                        if (currentConversationIndex !== -1) {
                            conversations[currentConversationIndex].model = currentModel;
                            saveCurrentConversation();
                        }
                    }
                });
            }
            
            // Load models when the page loads
            loadModels();
        });

        // Add a window event listener to ensure the stop button is hidden when the page is loaded
        window.addEventListener('load', function() {
            hideStopButton();
        });
    </script>
</body>
</html> 